import { Tab, Tabs } from 'rspress/theme';


# Plugin System

The `Code Updater` is designed to be highly customizable through its plugin system. This extensibility allows you to tailor the updater's behavior to fit your specific requirements.

## Build Plugin

The **Build Plugin** is used during the execution of the `code-updater deploy` command. Its primary function is to manage the build process for generating the required update bundles.

### Supported Plugins

- **`@code-updater/metro`**: Supports Metro bundler for React Native projects.
- **`@code-updater/repack`**: Coming soon.

## Storage Plugin

The **Storage Plugin** is utilized during the `code-updater deploy` command to upload bundles generated by the Build Plugin. It ensures that the update files are stored in a designated storage solution.

### Supported Plugins

- **`@code-updater/supabase`**: Provides `supabaseStorage` functionality, leveraging Supabase for storage.
- **`@code-updater/cloudflare`**: Provides `r2Storage` functionality, leveraging Cloudflare R2 for storage.
- **`@code-updater/aws`**: Provides `s3Storage` functionality, enabling the use of AWS S3 for storage.

## Database Plugin

The **Database Plugin** is responsible for storing the metadata required to check for updates. This plugin is activated during the execution of the `code-updater deploy` command.

### Supported Plugins

- **`@code-updater/supabase`**: Provides `supabaseDatabase` functionality, using Supabase as a database solution.
- **`@code-updater/aws`**: Provides `s3Database` functionality, utilizing AWS for database storage.
- **`@code-updater/postgres`**: Supports PostgreSQL for update metadata storage.
- **`@code-updater/cloudflare`**: Provides `d1Database` functionality, leveraging Cloudflare D1 for database storage.


## Example Usage

<Tabs>
    <Tab label="Supabase">
Here’s an example of how to configure `supabaseStorage` and `supabaseDatabase` with environment variables for a seamless storage setup:

```tsx
import { metro } from "@code-updater/metro";
import { supabaseStorage, supabaseDatabase } from "@code-updater/supabase";
import { defineConfig } from "code-updater";
import "dotenv/config";

export default defineConfig({
  build: metro({ enableHermes: true }),
  storage: supabaseStorage({
    supabaseUrl: process.env.CODE_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.CODE_UPDATER_SUPABASE_ANON_KEY!,
    bucketName: process.env.CODE_UPDATER_SUPABASE_BUCKET_NAME!,
  }),
  database: supabaseDatabase({
    supabaseUrl: process.env.CODE_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.CODE_UPDATER_SUPABASE_ANON_KEY!,
  }),
});
```

In this configuration:
- `supabaseUrl`: The base URL of your Supabase project, typically obtained from the Supabase dashboard.
- `supabaseAnonKey`: The anonymous API key for accessing Supabase, also available in the dashboard.
- `bucketName`: The name of the bucket where update bundles will be stored.

By using environment variables, sensitive information is kept secure and can be easily managed across environments.

</Tab>


 <Tab label="Cloudflare">
Here’s an example of how to configure `r2Storage` and `d1Database` with environment variables for a seamless storage setup:

```tsx
import { metro } from "@code-updater/metro";
import { d1Database, r2Storage } from "@code-updater/cloudflare";
import { defineConfig } from "code-updater";
import "dotenv/config";

export default defineConfig({
  build: metro({ enableHermes: true }),
  storage: r2Storage({
    bucketName: process.env.CODE_UPDATER_CLOUDFLARE_R2_BUCKET_NAME!,
    accountId: process.env.CODE_UPDATER_CLOUDFLARE_ACCOUNT_ID!,
    cloudflareApiToken: process.env.CODE_UPDATER_CLOUDFLARE_API_TOKEN!,
  }),
  database: d1Database({
    databaseId: process.env.CODE_UPDATER_CLOUDFLARE_D1_DATABASE_ID!,
    accountId: process.env.CODE_UPDATER_CLOUDFLARE_ACCOUNT_ID!,
    cloudflareApiToken: process.env.CODE_UPDATER_CLOUDFLARE_API_TOKEN!,
  }),
});

```

By using environment variables, sensitive information is kept secure and can be easily managed across environments.

</Tab>


 <Tab label="Only AWS S3">
Here’s an example of how to configure `s3Storage` and `s3Database` with environment variables for a seamless storage setup:

```tsx
import { metro } from "@code-updater/metro";
import { s3Storage, s3Database } from "@code-updater/aws";
import { defineConfig } from "code-updater";
import "dotenv/config";

export default defineConfig({
  build: metro({ enableHermes: true }),
  storage: s3Storage({
    bucketName: process.env.CODE_UPDATER_S3_BUCKET_NAME!,
    region: process.env.CODE_UPDATER_S3_REGION!,
    accessKeyId: process.env.CODE_UPDATER_S3_ACCESS_KEY_ID!,
    secretAccessKey: process.env.CODE_UPDATER_S3_SECRET_ACCESS_KEY!,
  }),
  database: s3Database({
    bucketName: process.env.CODE_UPDATER_S3_BUCKET_NAME!,
    region: process.env.CODE_UPDATER_S3_REGION!,
    accessKeyId: process.env.CODE_UPDATER_S3_ACCESS_KEY_ID!,
    secretAccessKey: process.env.CODE_UPDATER_S3_SECRET_ACCESS_KEY!,
  }),
});
```

By using environment variables, sensitive information is kept secure and can be easily managed across environments.

</Tab>


 <Tab label="AWS S3 + Postgres">
Here’s an example of how to configure `s3Storage` and `postgresDatabase` with environment variables for a seamless storage setup:

```tsx
import { metro } from "@code-updater/metro";
import { s3Storage } from "@code-updater/aws";
import { postgres } from "@code-updater/postgres";
import { defineConfig } from "code-updater";
import "dotenv/config";

export default defineConfig({
  build: metro({ enableHermes: true }),
  storage: s3Storage({
    bucketName: process.env.CODE_UPDATER_S3_BUCKET_NAME!,
    region: process.env.CODE_UPDATER_S3_REGION!,
    accessKeyId: process.env.CODE_UPDATER_S3_ACCESS_KEY_ID!,
    secretAccessKey: process.env.CODE_UPDATER_S3_SECRET_ACCESS_KEY!,
  }),
  database: postgres({
    host: process.env.CODE_UPDATER_POSTGRES_HOST!,
    port: process.env.CODE_UPDATER_POSTGRES_PORT!,
    user: process.env.CODE_UPDATER_POSTGRES_USER!,
    password: process.env.CODE_UPDATER_POSTGRES_PASSWORD!,
    database: process.env.CODE_UPDATER_POSTGRES_DATABASE!,
  }),
});
```

By using environment variables, sensitive information is kept secure and can be easily managed across environments.

</Tab>
</Tabs>
